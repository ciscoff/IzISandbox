package s.yarlykov.izisandbox.generics

/**
 * Covariance и Contravariance в обычных классах и интерфейсах.
 * -----------------------------------------------------------
 *
 * NOTE: Концепция вариантности (Variance) применяется не только к Generic'ам, но и к обычным
 * классам и интерфейсам.
 *
 * Класс содержит функции, а у функции как правило имеются "две стороны":
 * - аргументы (будем называть 'argument type')
 * - возвращаемое значение (будем называть 'return type')
 *
 * Соотвественно через аргументы своих OPEN-функций класс "принимает", а через их
 * возвращаемые значения "отдаёт". При наследовании и override'е open-функций нужно следить,
 * чтобы в дочернем классе соблюдались правила вариантности. Так в Kotlin/Java поддерживается
 * Covariance за счет того, что переопределяемая функция может возвращать "не больше предка". В
 * этом случае наследник всегда безопасно подменит предка там где из предка "читают". Однако в
 * в Kotlin/Java НЕ ПОДДЕРЖИВАЕТСЯ Contravariance - argument type переопределяемой функции
 * всегда должен быть ТОЧНО ТАКИМ ЖЕ как у предка и не может быть "шире". При наследовании
 * аргументы open-функций ИНВАРИАНТНЫ !!!
 *
 * NOTE: Запрет на Contravariance связан с поддержкой механизма overloading (не путай с override).
 * overloading - это когда можно иметь несколько функций с одинаковыми именами, но разными типами
 * аргументов. Чтобы сохранить механизм overloading решено отказаться он Contravariance. Поэтому
 * если мы хотим в наследнике сымитировать Contravariance, то можно просто добавить новую
 * функцию с нужными типами аргументов, но без override.
 *
 * Для того чтобы subtype был настоящим subtype'ом должны работать ДВА правила:
 * 1. наследник не должен отдавать больше родителя (то есть множество типов, ОТДАВАЕМЫХ
 *   наслеником, является подмножеством типов отдаваемых предком)
 * 2. наследник не должен ПРИНИМАТЬ МЕНЬШЕ родителя (то есть множество типов, ПРИНИМАЕМЫХ
 *   наслеником, равно или включает в себя подмножество типов, принимаемых предком)
 *
 */

abstract class Gizmo {
    abstract fun match(subj: Cat): Dog
}

abstract class SubGizmo : Gizmo() {
    // TODO Вот так Kotlin не позволяет, хотя это безопасно и удовлетворяет правилу 2.
    /*abstract override fun match(subj: Animal): Dog*/

    // TODO Реализация правила 1. Отдаем не больше предка, но могли и Dog поставить.
    abstract override fun match(subj: Cat): KindDog

}

fun main() {}
